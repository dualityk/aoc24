(AOC24 by k.)

(Day 11: Just bring me the stones.  You have one hour.  This solution is
 unfinished and very bad.)
'::
  "input11" READF #0 GET
  ("125 17")
  " " SPLIT
  
  (rules: A kcase structure representing all the stone's mogrifying rules.)
  { { :: TYPE Types.List == ; 
      :: _k dorules idx PUT ; }
    { :: "0" == ;
      :: "1" idx PUT ; }
    { :: LEN ODD NOT ;
      :: _k DUP LEN #2 / DUP2 
         LEFT #3 ROLLD RIGHT >INT "" + #3 ROLLD idx PUT DUP
         idx #1 + DUP 'idx STO LEFT 
         #3 ROLLD idx heretoend + + 
         max #1 + 'max STO ; }
    { #1
      :: >INT #2024 * "" + idx PUT ; } }
  
  (dorules: Run the rules against a list one time.)
  ':: DUP LEN
    '::
      '::
        DUP idx GET rules KCASE      
        idx #1 + DUP 'idx STO max < ;
      REP ;
    { max :idx: #0 }
    LOCAL ;
    
  ':: (main) list ':: dorules DUP LEN DISP ; #25 * EVAL LEN ;
  { dorules rules list } LOCAL ;
'day11 STO


(Day 10: Less than stellar cartography)
'::
  (Turn the input data into an integer array.)
  "input10" READF POP DROP
  '::
    DUP LEN
    '::
      (A single row:) {}
      '::
        text cursor GET >INT +
        cursor #1 + DUP 'cursor STO max < ; 
      REP update ;
    { max text :cursor: #0 } LOCAL ;
  FOREACH
  (Hang onto the dimensions.)
  DUP LEN SWAP DUP #0 GET LEN SWAP

  (ascend: Recursively paint our way to the top of a trail.)
  '::
    (Hang onto our sought number.)
    seeking
    '::
      (Is the tile we're on the number we're seeking?)
      map x y get2d DUP seeking ==
      ':: 
        (We should be here.  Are we at the summit?) 
        summit == 
        '::
          (We are at the summit, so add an ID for this site to our list.)
          x y ybound * + + ;
        '::
          (We have yet to summit, so continue to ascend.)
          seeking #1 + 'seeking STO
          'ascend paint ;
        IFTE ;
      'DROP
      IFTE ;
    { seeking y x } LOCAL ;

  (uniques: Count up the number of unique items in a list.)
  '::
    (Sort the list first.)
    sort
    DUP LEN DUP
    '::
      (We have at least one item.  Do we have two?)
      #1 - DUP
      '::
        (Yes.)
        '::
          (Our unique count begins here:) #1
          '::
            (Compare current item with previous item, move the cursor,
             and add the inequality to our count of uniqueness.)
            list size GET
            list size #1 - DUP 'size STO GET
            != + 
            size ;
          REP ; 
        { size list } LOCAL ;
      ':: (One item means one unique item.) DROP DROP #1 ;
      IFTE ;
    (No items means no uniqueness.)
    ':: DROP DROP #0 ;
    IFTE ;
  
  '::
    (Part 1: Cataloging ways to the summit.)
    (Also part 2: Doing that some more in a way that was coincidentally
     straightforward with this original code.)
    (Part one's tally is here:) #0
    ybound
    '::
      '::
        y #1 - 'y STO
        xbound      
        '::
          '::
            x #1 - 'x STO
            (We only care about zero altitude squares for this one.)
            map x y get2d NOT
            '::
              (A zero was found, so we start here.)
              (Our list of summits:) {}
              x y ascend 
              (This is the part 2 thing.)
              DUP LEN allsummits + 'allsummits STO
              (Find just the number of unique values in the returned list.)
              uniques + ;
            IFT
            x ;
          REP ;  
        { x :seeking: #0 :summit: #9 } LOCAL 
        y ;
      REP ;
    { y } LOCAL 
    "Part 1: " SWAP + DISP 
    "Part 2: " allsummits + DISP ;
  { uniques ascend paint map xbound ybound :allsummits: #0 } LOCAL ;
'day10 STO


(Day 9: Stretching the Christmas metaphor with filesystem fragmentation)
'::
  (Fetch once more the input data.  De-interleave it into lists of lengths
  and free space.)
  {} {}
  "input09" READF #0 GET
  DUP LEN
  '::
    '::
      idx #1 - 'idx STO
      input idx GET >INT SWAP + SWAP
      idx ;
    REP ;
  { idx input } LOCAL

  (sumrange: Sum a range of natural numbers from x to y.)
  ( n*[n+1]/2 - [n-1]*n/2 )
  ':: DUP #1 + * #2 / 
     SWAP DUP #1 - * #2 / - ;

  (Part one.)
  '::
    (Right index.)
    files LEN
    '::
      '::
        (Check for free space:) free
        '::
          (There is free space.  Are there any remaining blocks to move?)
          part
          '::
            (Yes.  Move as many blocks as will fit into the remaining free
             space, and update the checksum.)
            diskpos DUP
            part free lesser
            (Subtract this value from both remaining block counters.)
            DUP part SWAP - 'part STO
            DUP free SWAP - 'free STO            
            (Move our position pointer by the same amount.)
            + DUP 'diskpos STO
            (Write the checksum for the movable portion.) 
            #1 - sumrange rightidx * sum + 'sum STO ;
          ':: 
            (There are no blocks to move, so advance to the next movable
            file, and fetch its remaining block count.)
            rightidx #1 - 'rightidx STO 
            files rightidx GET 'part STO ;
          IFTE ;
        '::
          (There is no free space to fill, get the next fixed file.)
          (Grab our new free space and remember it.)
          empty leftidx GET 'free STO
          (Hang onto the old disk position, then get a fixed file's length.)
          diskpos DUP
          files leftidx GET
          (Our new position is at the end of it:)
          + DUP 'diskpos STO
          (Write the checksum for the movable portion.) 
          #1 - sumrange leftidx * sum + 'sum STO
          (And move the index right.)
          leftidx #1 + 'leftidx STO 
          (If we're at the crossover point, let the partial finish doing its
           thing regardless.)
          rightidx leftidx == ':: part 'free STO ; IFT ;
        IFTE
        (Repeat until out of both free space and partials.)
        rightidx leftidx != part OR ;
      REP
      "Part 1: " sum + DISP ;
    { rightidx :leftidx: #0 :sum: #0 :diskpos: #0 :free: #0 :part: #0 }
    LOCAL 

    (Part 2: Move only complete files to compact disk.)
    (Make one pass to generate our initial cache of search positions,
     as well as the absolute position of un-moved files and the beginning
     of free space.)
    empty LEN
    '::
      (Disk position begins:) #0
      '::
        (Check to see if it's time to update our cache.)
        empty cursor GET DUP cachepos >=
        '::
          (We found a new cache entry.  Append as many to the list as
           needed.)
          '::
            cursor cache SWAP + 'cache STO
            cachepos #1 + 'cachepos STO 
            DUP cachepos >= ;
          REP ;
        IFT DROP
        
        (Grab the file size at our cursor.)
        files cursor GET
        (Record the current disk position as the beginning of the file.)
        SWAP DUP filepos SWAP + 'filepos STO
        (And the end of it as the beginning of free space.)
        + DUP emptypos SWAP + 'emptypos STO
        (Then advance past the free space.)
        empty cursor GET +
        
        cursor #1 + DUP 'cursor STO max <  ;
      REP
      (Now write out the final file position, flesh out the cache, and return 
       everything.)
      filepos SWAP +
      emptypos
      cache DUP LEN #11 SWAP - max #1 >LST SWAP * + ;
    { max :cache: {} :cachepos: #0 :filepos: {} :emptypos: {} :cursor: #0 } 
    LOCAL
    
    (storefile: Record the checksum for the current file at an indicated
     position.)
    '::
      ':: 
        (Store checksum.)
        emptypos position GET DUP size + #1 -
        sumrange fileid *
        sum + 'sum STO
        (Deduct free space from new position.)
        empty DUP position GET size - position PUT 'empty STO 
        (And update list of starting positions.)
        emptypos DUP position GET size + position PUT 'emptypos STO ;
      { position fileid } LOCAL ;
      
    files LEN
    '::
      '::
        (Move right index one stop left.)
        rightidx #1 - 'rightidx STO
        (Grab the size of the next file.)
        files rightidx GET
        (Determine the leftmost place it can move, using the cache.)
        DUP cache SWAP GET
        '::
          (Is that place in range?)
          cursor rightidx <=
          '::
            (Store the file in this position.)
            rightidx cursor storefile
            (And update the cache by searching from there to rightidx for the
             next matching empty space of the size we just left, as well as
             any larger cache entries we may have clobbered.)
            empty cursor GET 'size STO
            cache size GET 'cursor STO
            '::
              (Check the empty space under our cursor to see if it meets
               the criteria.)
              cursor rightidx <
              ':: empty cursor GET size >= ;
              #0 IFTE
              '::
                (It does, so update the cache, advance to the next larger
                 file size, and continue until the cache is fully updated.
                 The next cache entry will always be to the right, so
                 we're searching incrementally by resetting the cursor to
                 the next cached value if it's greater than the present one.)
                cache cursor size PUT 'cache STO  
                size #1 + DUP 'size STO #10 < 
                cache size GET cursor greater 'cursor STO ;
              '::
                (It doesn't: continue seeking until we hit the search
                 limit.)
                cursor #1 + DUP 'cursor STO rightidx < 
                DUP NOT 
                ':: 
                  (We hit the limit, so invalidate this entry and advance,
                   which will invalidate all subsequent entries.)
                   rightidx 'cursor STO
                  DROP cache cursor size PUT 'cache STO
                  size #1 + DUP 'size STO #10 < ;
                IFT ;
              IFTE ;
            REP ;
          '::
            (No, store the file in its original position.)
            filepos rightidx GET DUP size + #1 -
            sumrange rightidx *
            sum + 'sum STO ;
          IFTE ;
        { cursor size } LOCAL
        (And repeat until we are out of files to move.)
        rightidx ;  
      REP "Part 2: " sum + DISP ;
    { rightidx storefile cache emptypos filepos :sum: #0 }
    LOCAL ;
  { sumrange empty files } LOCAL ;
'day09 STO


(Day 8: y=mx+b, but with the Easter bunny)
'::
  (Fetch the input data, and the size of the map we've read in.)
  "input08" READF POP DROP
  (Y size:) DUP LEN
  (X size:) SWAP DUP #0 GET LEN
  
  (First, build a list of coordinates sorted by antenna type.  We're just
   going to use ASCII minus 48, which will make 0 the minimum value, and
   z will be the maximum value at 74.)
  '::
    { {} } #75 *
    ybound
    '::
      '::
        (Get the next input line.)
        input idy #1 - DUP 'idy STO GET
        xbound
        '::
          '::
            (Get a character value.  Is it 0 or above?)
            text idx #1 - DUP 'idx STO GET ASC> #48 -
            DUP #0 >=
            '::
              (Yes, add coordinates to the appropriate list.)
              DUP2 GET idx idy #2 >LST #1 >LST + SWAP PUT ;
            'DROP IFTE
            idx ;
          REP ;
        { idx text } LOCAL idy ;
      REP ;
    { idy } LOCAL
    
    (Now, make a blank truth map.)
    { #0 } xbound * #1 >LST ybound *
    
    (genpair: Generate a pair of non-interfering coordinates from a pair of
     antennae.)
    '::
      (Shake the coordinates out of the lists we were given.)
      OBJ> DROP #3 ROLL OBJ> DROP 
      '::
        (Obtain a 2x delta.)
        xa xb - #2 * ya yb - #2 *
        ':: 
           xa deltax - ya deltay -
           xb deltax + yb deltay +
        ;
        { deltay deltax } LOCAL ;
      { yb xb ya xa } LOCAL ;
    
    (genrepeat: Generate repeating coordinates in both directions across a
     line scribed by a pair of antennae.)
    '::
      (Save start coordinates, then shake out our lists as before..)
      DUP #3 ROLLD OBJ> DROP #3 ROLL OBJ> DROP
      (Generate just a delta pair.)
      #3 ROLL - #3 ROLLD SWAP -
      (Unpack the start coordinates again.)
      #3 ROLL OBJ> DROP
      '::
        (First march forward until we hit the wall.)
        ':: 
          x deltax multiplier * direction
          y deltay multiplier * direction
          DUP2 bounded
          (Mark every spot we hit and increase our multiplier.)
          ':: markmap multiplier #1 + DUP 'multiplier STO ; 
          (If we left the map, forget the coordinates and see if we need to
           go the other direction still.)
          ':: DROP DROP 
            (Reset the multiplier to 1, since we already did 0.)
            #1 'multiplier STO
            (See if we already changed the direction.)
            'direction RCL '- ==
            (Yes, stop.)
            #0
            ':: (No, reverse it and continue.) '- 'direction STO #1 ;
            IFTE ;
          IFTE ;
        REP ;
      { y x deltax deltay :direction: + :multiplier: #0 } LOCAL ;
    
    (runcombos: Evaluate a thing against every combination of two items in a
     list.  Accepts a list and an evaluator.)
    '::       
      (Arrange the stack as we see fit.)
      SWAP DUP car SWAP cdr DUP LEN
      (At least two list items are required to play this game:) DUP
      '::
        '::
          (Cycle through each combination of the first and remaining
           elements.)
          '::
            fixedobj list idx #1 - DUP 'idx STO GET evaluator idx ;
          REP
          (Save our relevant info from the local context.)
          list 'evaluator RCL ;
        { idx list fixedobj evaluator } LOCAL 
        runcombos ; 
      ':: #4 DROPN ;
      IFTE ;
    
    (markmap: Store #1 to some location on the truth map.)
    ':: map #3 ROLLD #1 put2d 'map STO ;
     
    '::
      (Part 1: Plot each antinode and count up the number of unique ones.)
      antennae
      '::
        (Because of how we stored our lists of antennae, we need to skip
         blank ones.)
        DUP LEN
        '::
          ':: 
            (We're supplied two { x y } coordinate pairs.  First generate new
             ones.)
            genpair 
            (Then store them both back to the map if they're in bounds.)
            DUP2 bounded 'markmap ':: DROP DROP ; IFTE
            DUP2 bounded 'markmap ':: DROP DROP ; IFTE ;
          runcombos ;
       'DROP IFTE ; FOREACH DROP
      
      (And sum the truths on our map.)
      #0 map ':: sumlst + ; FOREACH DROP
      "Part 1: " SWAP + DISP
      
      (Part 2: Repeat each antinode to the ends of the map.  There's no need
       to erase it since all the true parts of the old map will be true on
       the new one.)
      antennae
      '::
        DUP LEN
        ':: 'genrepeat runcombos ;
        'DROP IFTE ; 
      FOREACH DROP    

      (And sum the truths on our map.)
      #0 map ':: sumlst + ; FOREACH DROP
      "Part 2: " SWAP + DISP ;
    { markmap runcombos genrepeat genpair map antennae } LOCAL ;
  { xbound input ybound } LOCAL ;
'day08 STO


(Day 7: Doing math by a bridge)
'::
  (Fetch the input data.)
  "input07" READF POP DROP

  (Process the list into lines of the form { result term1 term2 ... }.)
  '::
    (First break the line around the colon.)
    ":" SPLIT OBJ> DROP
    (The second part of the line is our list of terms.  Strip the leading
     space, then make them ints.)
    #1 heretoend " " SPLIT
    ':: >INT update ; FOREACH
    (Reverse the order of the terms.)
    revlst
    (Turn the result into an int as well, combine the list and update.)
    SWAP >INT SWAP + 
    update ;
  FOREACH
      
  (mkoperators: Given a number of operators to generate, and a start value,
   progressively pick between / and * and return code.  This is just
   glorified decimal to binary (the glory being it can do other bases.)
  '::
    '::
      (Our blank code:) ':: ;
      '::
        (Grab our start value, check the remainder, then divide it down.)
        SWAP DUP base MOD SWAP base / SWAP
        (Pick the appropriate value from the operators list and append.)
        operators SWAP GET #3 ROLL +
        bits #1 - DUP 'bits STO ;
      REP
      (Get rid of our accumulated result, hand back just the code.)
      SWAP DROP 
      (And the validity flag.) ;
    { bits } LOCAL ;
  STATICN
  
  (combinations: Generate a list of operator combinations for between 2 and
   11 binary operators, the range represented by our input.  Accepts a list
   of possible operators.)
  '::
    (Record the number base we're working in.)
    DUP LEN 
    '::
      (The main list begins here:) { {} } #12 *
      '::
        (The sub-list begins here:) {}
        base idx ^
        '::
          (Decrement and generate a new combination.)
          #1 - DUP idx mkoperators
          #3 ROLL + 
          (Reset the stack and repeat until we reach zero.)
          SWAP DUP ;
        REP
        (Discard the counter, then insert the new sub-list into the main list.)
        DROP idx PUT
        idx #1 - DUP 'idx STO 
        (Keep going until we leave the range we care about.)
        #1 != ; 
      REP ; 
    { base operators :idx: #11 } LOCAL ;
  STATICN
  
  (ckline: Check one line against its possible combination of operators.)
  '::
    (First get the right list of combinations for the needed quantity of
     operators.)
    DUP LEN #2 - combos SWAP GET 
    (And the size of that list.)
    DUP LEN
    '::
      (By default our result is false:) #0
      '::
        (Expand the terms from our line, discarding its length.)
        line OBJ> DROP
        (Decrement our index and run the next combination.)
        ourcombos idx #1 - DUP 'idx STO GETE
        (Update our success flag; stop repeating if successful or no more
         indices.)
        == OR DUP NOT idx AND ;
      REP ;
    { idx ourcombos line } LOCAL ;
  STATICN
    
  (concat: Take the space out between two integers.)
  ':: "" + SWAP + >INT ;
  STATICN
  
  '::
    (Part one: go through the list and sum the things which could be true.)

    (Our sum starts here:) #0
    
    (First, build the list of tests: our operators are * and +.)
    { :: `* ; :: `+ ; } combinations
    
    (Then check each line in turn to see if it's any good.)
    input LEN
    '::
      '::
        input idx #1 - DUP 'idx STO GET
        ckline
        ':: (Success: add the result to our tally.)
          input idx GET #0 GET + ;
        ':: (Failure: add the equation to our fail list.)
          input idx GET #1 >LST badeqs + 'badeqs STO ;
        IFTE
        idx ;
      REP ;
    { idx combos } LOCAL 
  
    (Our sum continues from the previous part.)
    DUP "Part 1: " SWAP + DISP
    
    (Part 2: What if there was a whole new kind of operator?)
    (Now, build a list of tests including the new thing.)
    { :: `* ; :: `+ ; :: concat ; } combinations

    (Then check each previously bad line in turn to see if it's any good.)
    (This is a bad and slow method.  I'm not sure how to fix that.  Part of
     its slowness is because concat is slow, but mostly it's because 2048
     tests, 2^11 is a lot less than 177k tests, 3^11, even with duplicates
     removed.)
    badeqs LEN
    '::
      '::
        badeqs idx #1 - DUP 'idx STO GET
        ckline
        ':: (Success: add the result to our tally.)
          badeqs idx GET #0 GET + ;
        IFT
        idx ;
      REP ; 
    { idx combos } LOCAL
    "Part 2: " SWAP + DISP ;
  { concat ckline combinations mkoperators input :badeqs: {} } LOCAL ;
'day07 STO


(Day 6: Meandering through a maze)
'::
  (Fetch the input data.)
  "input06" READF POP DROP
  
  (objects: Evaluating a square will cause something to happen.  These
   things originally needed to be in place early because the input data is
   turned into them.)
  [dir: 
  
    :empty: 
    :: (Empty spaces become full spaces, and suck the guard in.)
      map x y 'objects.touched put2d 'map STO
      (Add our location to the unique steps list.)
      uniquesteps x y #2 >LST #1 >LST + 'uniquesteps STO
      x y evalsquare ;
    :touched:
    :: (Touched spaces just suck the guard in.)
      x 'xcursor STO y 'ycursor STO #1 ;
    :obstacle: 
    :: (Obstacles cause the guard to change direction without moving.)
      spinguard #1 ; ]
      
  (moves: Guard's available motions.)
  { :: (N) xcursor ycursor #1 - ;
    :: (E) xcursor #1 + ycursor ;
    :: (S) xcursor ycursor #1 + ;
    :: (W) xcursor #1 - ycursor ; }

  (evalsquare: Evaluate a given square.  Accepts x,y coordinates and
   returns false if the requested square is out of bounds; the square
   itself is responsible for returning true.)
  '::
    ':: 
      (Check for bounds before dispatching.)
      x #0 >= y #0 >= AND
       ':: x xbound < y ybound < AND
        ':: map y GET x GETE ;
        #0 IFTE ;
      #0 IFTE ;
    { y x } LOCAL ;

  (spin: Pick next orientation.)
  ':: #1 + #4 MOD ;

  (spinguard: Rotate the guard specifically.)
  ':: orientation spin 'orientation STO ;

  '::
    (Record the size of the map.)
    map DUP LEN 'ybound STO
    DUP #0 GET LEN 'xbound STO
    
    (And rewrite it into a list of symbols.)
    '::
      (Replace each line from the input with a list of square behaviors.)
      '::
        (Aforementioned list:) {}
        ':: 
          (Pick from the options.  ^ is a special case that records our
           guard's start position.)
          text cursor GET 
          { { :: "." == ; 'objects.empty }
            { :: "#" == ; 
              ::
                (Record a list of obstacles for part 2.)
                obstacles cursor idx #2 >LST #1 >LST +
                'obstacles STO
                'objects.obstacle ; }
            { :: "^" == ; 
              :: cursor 'startx STO
                 (idx is set here by FOREACH.)
                 idx 'starty STO
                 'objects.empty ; } }
          KCASE
          (Append the symbol to our list and move on.)
          +
          cursor #1 + DUP 'cursor STO xbound < ;
        REP
        (Write the new list back, gradually overwriting the input text.)
        update ;
      { text :cursor: #0 } LOCAL ;
    FOREACH 'map STO

    (Part one: find the unique squares the guard visits.)
    '::
      (First land on the initial square.)
      xcursor ycursor evalsquare DROP
      (Then walk around until we fall off the map.)
      ':: moves orientation GETE evalsquare ; REP
      "Part one: " uniquesteps LEN + DISP ;
    { :loopcount: #0 :orientation: #0 
      :xcursor: startx :ycursor: starty } LOCAL
    
    (Part two: where time becomes a loop.)
    '::
      (seekobstacle: For a given starting position, and move, return the
       position of the next obstacle and True, or False if there is none.)
      '::
        '::
          (Move as directed.)
          move DUP2 'ycursor STO 'xcursor STO
          (Check for bounds.)
          bounded
          '::  
            (Bounded: did we hit anything?)
            map ycursor GET xcursor GET 'objects.obstacle ==
            '::
              (Yes: record our cursor, and tell REP to stop.)
              xcursor ycursor #2 >LST #0 ;
            ':: (No: keep searching.) #1 ;
            IFTE ;
          '::
            (Left map, return null list and tell REP to stop.)
            {} #0 ;
          IFTE ;
        REP ;
      { move ycursor xcursor } LOCAL ;
    
    (tports: A second map containing obstacle teleport data.)
    { {} } xbound * #1 >LST ybound *
    
    (castrays: Build a list of the next obstacles hit when coming at this
     one from every cardinal direction.)          
    '::
      '::
        tports
        (Move out one square counter to the guard's vector, then turn left 
         and straight on til morning, for all four directions.)
        '::
          moves idx #1 + spin GETE
          moves idx spin GET seekobstacle 
          idx #1 + DUP 'idx STO #4 < ;
        REP
        #4 >LST
        (Record teleport data.)
        xcursor ycursor #3 ROLL put2d 'tports STO ;
      { ycursor xcursor :idx: #0 } LOCAL ;
    
    (absorbrays: Slightly different raycasting, to update everything
     pointing at the new obstacle.)
    ':: 
      (Hang onto our current location.)
      '::
        '::
          hitx hity
          (Get our two relevant directions: straight out, and off to the right.)
          moves idx GET
          moves idx spin GET
          '::
            '::
              (Take a step and update cursor.)
              map travel DUP2 'ycursor STO 'xcursor STO
              (Are we in bounds?)
              DUP2 bounded
              '::
                (We're in bounds, were we free to move this way?)
                get2d 'objects.obstacle !=
                '::
                  (Yes, goooood.  Now let's see if we can look right.)
                  map peek DUP2 bounded
                  ':: 
                    (We can see right.  Is there an obstacle there?)
                    get2d 'objects.obstacle ==
                    '::                    
                      (Fetch the obstacle's map and update it to point to us
                       in the direction we're headed, e.g.  an east value if
                       searching east.)
                      tports DUP peek get2d
                      hitx hity #2 >LST idx spin PUT
                      peek #3 ROLL put2d 'tports STO ;
                    IFT
                    (Keep looking either way) #1 ;
                  ':: 
                    (Can't look right, forget the map and coordinates and stop.)
                    DROP DROP DROP #0 ; 
                  IFTE ;
                (We're done here if we hit an obstacle.) #0
                IFTE ;
              ':: (Forget the map and coordinates and stop.) DROP DROP DROP #0 ;
              IFTE ;
            REP ;
          { peek travel ycursor xcursor } LOCAL
          idx #1 + DUP 'idx STO #4 < ;
        REP ;
      { :idx: #0 } LOCAL ;
    

    (The main search section.)
    '::
      "Casting original obstacle rays" DISP
      (Cast rays from each obstacle and update its teleport map.)
      obstacles
      ':: OBJ> DROP castrays ;
      FOREACH DROP
      "Seeking through unique obstacle positions" DISP
      uniquesteps LEN
      '::
        '::
          (Local copies of the map and teleports.)
          map tports
          (Get the next obstacle position.)
          uniquesteps idx #1 - DUP 'idx STO GET OBJ> DROP
          
          '::
            (Modify our map with the new obstacle.)
            map hitx hity 'objects.obstacle put2d 'map STO
            (Cast rays out from this obstacle.)
            hitx hity castrays
            
            (Debug: print our map back to us.
            map
            " " hitx * "↓" + hity + DISP
            ':: ':: 'objects.obstacle == "#" "." IFTE DISPN ; FOREACH DROP " " DISP ; FOREACH
            DROP)
            
            (And update the teleport data for any obstacles pointed at us.)
            absorbrays
            
            (Now seek north from the start position until hitting an obstacle.)
            startx starty
            '::
              xcursor ycursor moves orientation GET seekobstacle ;
            { ycursor xcursor } LOCAL
            
            (We should have an obstacle address here.)
            (Bounce around til we leave the map or hit a given obstacle more
             than once from the same direction.)
            '::
              (Get our current spot from tports, and mark it hit from our
               direction.)
              DUP tports SWAP OBJ> DROP get2d DUP orientation GET
              ( { coords } { spot orientations } { new spot } )
              SWAP "Done" orientation PUT #3 ROLL OBJ> DROP
              ( { new spot } { done orientations } coordx coordy )
              #3 ROLL tports #4 ROLLD put2d 'tports STO
              ( { new spot } )
              DUP
              (If we hit this item before, we are in a loop.)
              "Done" ==
              '::
                loops #1 + 'loops STO DROP #0 ;
              '::
                (If the item is not null, advance orientation and repeat.)
                DUP
                ':: spinguard #1 ;
                (If it is null, we have left the map and are done.)
                ':: DROP #0 ;
                IFTE ;
              IFTE ;
            REP ;
          { hity hitx tports map :orientation: #0 } LOCAL 
          idx ;
        REP ;
      { idx } LOCAL 
      "Part 2: " loops + DISP ;
    { absorbrays castrays tports seekobstacle :loops: #0 } LOCAL ;
    
  { spinguard spin evalsquare moves objects map
    :startx: #0 :starty: #0 :xbound: #0 :ybound: #0 
    :uniquesteps: {} :obstacles: {} } LOCAL ;
STATICN
'day06 STO


(Day 5: Every technical manual project ever, I'm sure)
'::
  (Today's input comes in two parts.)
  "input05" READF

  (mklist: Given a delimiter string, make a list of lists of integers.
   This is the common procedure for both halves of our input data.) 
  '::
    '::
      (Our list starts blank:) {}
      '::
        (Get a line and split it around our delimiter.)
        input idx GET delimiter SPLIT 
        (Update the line with strings converted to integers.)
        ':: >INT update ; FOREACH
        (Drop our list into a list, and concatenate.)
        #1 >LST +
        (Advance idx and stop if we get to a null string.)
        input idx #1 + DUP 'idx STO GET "" != ;
      REP ;
    { delimiter } LOCAL 
    (After we're done with a part, advance past the blank line.)
    idx #1 + 'idx STO ;
    
  (Actually parse the input here and leave it on the stack.)  
  '::
    (The first half of our data is separated by "|".)
    "|" mklist
    (The second half is separated by ",".)
    "," mklist ; 
  { mklist input :idx: #0 } LOCAL 
  
  (Now that we have machine readable data, it's named here.)
  '::
    (For this section, we're going to build a semi-sparse lookup table:
     every 'before' page will have a 100-entry bitmap which will have a flag
     for every 'after' rule.)     
    (One page's empty map:)
    { #0 } #100 *
    (And one hundred pages:)
    #1 >LST #100 *
    (Now build the table right on the stack.)
    rules LEN 
    '::
      '::
        (Decrement index and get a rule.)
        rules idx #1 - DUP 'idx STO GET
        (Retrieve both sides, and line up our stack.  This leaves us with
         the 'after' index, 'before' index, all the rules, and the bitmap.)
        OBJ> DROP SWAP
        #3 ROLL SWAP DUP2 GET
        (Now bring in a flag, roll the 'after' index into place and put it
         all back.)
        #1 #5 ROLL PUT SWAP PUT
        idx ;
      REP ;
    { idx } LOCAL

    (validate: To validate a single manual, we start at the end, and
     progressively validate each page against the rest of the list.)
    '::
      (Grab its number of pages -- we start second from the end.)
      DUP LEN #1 -
      '::
        (We start out good:) #1
        '::
          (Grab the rules map for the previous page, and a list of pages 
           from here to the end.)
          ruletable manual 
          idx #1 -
          GET GET manual idx heretoend
          DUP LEN
          (Validate just the rest of the manual from this page.)
          '::
            '::
              (Get the next page to check from our search list.)
              map searchlist idx #1 - DUP 'idx STO GET 
              (Get the rule from the map, and see if we're good..)
              GET AND DUP
              (Repeat so long as there are more indices and no failures.)
              ':: DUP idx AND ;
              (If there is a failure, hand our index back.)
              ':: DROP idx #0 #0 ;
              IFTE ;
             REP ;
          { idx searchlist map } LOCAL
          (Repeat until all pages are checked, if no failures.)
          DUP
          ':: idx #1 - DUP 'idx STO ;
          (If there was a failure, return our failed indices.)
          ':: DROP idx + idx #1 - #0 #0 ; 
          IFTE ;
        REP ;
      { idx manual } LOCAL ;
      
    manuals LEN 
    ':: 
      (Our tally for valid manuals begins here:) #0
      ':: 
        (Grab the next manual from the library, and validate it.)
        manuals idx #1 - DUP 'idx STO GET 
        (Also hang onto the manual in case of success.)
        DUP validate
        (NOW THEN.  If our manual is correct, unfold it to the middle and
         see what the page number is, and add it to our tally.) 
        ':: DUP LEN #1 - #2 / GET + ;
        (Otherwise, add it to our incorrect list for the next section.)
        ':: DROP DROP incorrect SWAP #1 >LST + 'incorrect STO ;
        IFTE
        idx ;
      REP 
      "Part one: " SWAP + DISP

      (Now for part 2, yeeey.  This part is similar, except it listens to
       the validator's specific complaints about page order, and tries to
       please it.)
      incorrect LEN 'idx STO
      (Our tally again begins here:) #0
      '::
        (Grab the next manual.)
        incorrect idx #1 - DUP 'idx STO GET
        '::
          (Save the manual and validate it.) 
          DUP validate 
          ':: (It's valid, so it's time to stop.) #0 ;
          ':: (It's invalid, so rearrange the failed pages and try again.)
             swapelements #1 ;
          IFTE ;
        REP 
        (Once the terms are rearranged to the machine's satisfaction,
         unfold the manual as before to add to the tally.)
        DUP LEN #1 - #2 / GET +
        idx ;
      REP
      "Part two: " SWAP + DISP ;
    { idx validate ruletable :incorrect: {} } LOCAL ;
  { manuals rules } LOCAL ;
'day05 STO


(Day 4: Word Girl)
'::
  (Fetch our input, and record its dimensions.)
  "input04" READF POP DROP
  (First get the Y dimension.)
  DUP LEN 
  (Then the X dimension.  Leaves us with the list, ymax, and xmax.  The
   latter two are duplicated as starting coordinates for our search later.)
  SWAP DUP #0 GET LEN #3 ROLL DUP2

  (deltas: Here are the eight directions we can go, expressed as X-Y 
   deltas, along with the most efficient bounds check for each. The elements
   are stored as code so they automatically expand onto the stack when GETEd.)
  { :: (N)   #0 #-1 ':: y #0 >= ; ;
    :: (NE)  #1 #-1 ':: y #0 >= x xmax < AND ; ;
    :: (E)   #1  #0 ':: x xmax < ; ;
    :: (SE)  #1  #1 ':: x xmax < y ymax < AND ; ;
    :: (S)   #0  #1 ':: y ymax < ; ;
    :: (SW) #-1  #1 ':: x #0 >= y ymax < AND ; ;
    :: (W)  #-1  #0 ':: x #0 >= ; ;
    :: (NW) #-1 #-1 ':: x #0 >= y #0 >= AND ; ; }
  
  (chase: Chase in one direction after a word, and return a success boolean.
   It accepts an index for the match string, normally #1 unless recursing,
   and assumes the first letter is already determined to be correct.) 
  '::
    (Succeed if the end of the string has been reached.)
    DUP match LEN ==
    ':: DROP #1 ;
    '::
      (Otherwise, move the cursor temporarily.)
      x xdir + y ydir +
      '::
        (Fail if we left the map.)
        inbounds
        ':: 
          (We're still in bounds: how's our letter lookin'?)
          map y GET x GET match cursor GET ==
          (If it's good, advance cursor and recurse.  Otherwise fail out.)
          ':: cursor #1 + chase ; #0 IFTE ;
        #0 IFTE ;
      { y x cursor } LOCAL ;
    IFTE ;
  
  (spin: From a given spot on the map, return the sum of matches after
   fanning out in every direction in our deltas list.)
  '::
    (Our sum:) #0
    deltas LEN
    '::
      '::
        (Step back through the list.) 
        deltas idx #1 - DUP 'idx STO GETE
        (Temporarily bind the particulars about our chosen direction,
         and chase.)
        ':: #1 chase ; { inbounds ydir xdir } LOCAL
        (Add to our sum and repeat as needed.)
        + idx ;
      REP ;
    { idx } LOCAL ;
  
  ':: 
    (Part 1: finding all the ecksmases.)
    (We start with no ecksmas at all:) #0
    '::
      (Decrement Y position.) y #1 - 'y STO
      (Reset X.) xmax 'x STO
      '::
        (Get our current line.)
        map y GET
        (Decrement X position and get our current character.)
        x #1 - DUP 'x STO GET
        (If the first letter matches, fan out from here and get a sum of
         complete matches to add to the list.)
        match #0 GET ==
        ':: spin + ; IFT
        x ;
      REP y ; 
    REP
    "Part 1: " SWAP + DISP

    (Part 2: finding all the X-mases.  This loop differs from part 1 in 
     that it avoids the borders of the map, and it's looking for the middle
     letter instead of the first.)
    (We start with no Xes at all:) #0
    (Adjust our borders inward by 2, since our decrements are now at the
     end of their respective loops.  And also reset Y from part 1.)
    xmax #2 - 'xmax STO ymax #2 - DUP 'ymax STO 'y STO
    '::
      (Reset X.) xmax 'x STO
      '::
        (Get our current character and see if it's the middle one.)
        map y GET x GET "A" ==
        '::
          (We don't actually care about direction, just that the letters
           S and M are diagonal to one another both ways.  One solution
           is to see if their ASCII values sum to 160.)
          (Get / characters.)
          map y #1 - GET x #1 + GET ASC>
          map y #1 + GET x #1 - GET ASC> + #160 ==
          (Get \ characters.)
          map y #1 - GET x #1 - GET ASC>
          map y #1 + GET x #1 + GET ASC> + #160 ==
          (Add 1 to our count if both these things are true.)
          AND + ;
        IFT
        (Decrement X position.  Putting it down here skips column 0.)
        x #1 - DUP 'x STO ;
      REP 
      (Decrement Y position.  Putting it down here skips row 0.) 
      y #1 - DUP 'y STO ; 
    REP
    "Part 2: " SWAP + DISP ;
  { spin chase deltas x y xmax ymax map :match: "XMAS" } LOCAL ;
'day04 STO


(Day 3: IT'S PARSE TIME BOYS)
':: 
  (Fetch our input into a list of strings, as usual.)
  "input03" READF POP DROP
  
  (advance: This routine advances the cursor through the current text,
   and both records and returns the !EOL flag.)
  ':: cursor + DUP 'cursor STO
     text LEN < DUP 'eol STO ;

  (evaliftrue: Given a boolean and an object, either evaluate it or return 
   false.  The kids call this syntactic sugar.)
  ':: #0 IFTE ;
  
  (getdigits: Acquire up to three consecutive numerals, and return as a
   string if successful.  Trailing garbage is gleefully ignored.)
  '::
    text cursor GET DUP isnumeral
    '::
      (We have already succeeded.  Keep our digit and try for 1-2 more.)
      #1 advance
      ':: text cursor GET DUP isnumeral
        ':: + #1 advance 
          ':: text cursor GET DUP isnumeral 
            ':: + #1 advance ;
            IFT DROP ;
          'DROP IFTE ;
        'DROP IFTE ;
      'DROP IFTE
      (We succeeded:) #1 ;        
    (We failed: the first digit was not a numeral.)
    ':: DROP #0 ;
    IFTE ;
  
  (rules: These are the rules for matching a mul instruction.  They must all 
   be met, in order, to generate a valid instruction.)
  { ::
      (First, it must start with "mul(".)
      text cursor DUP #3 + SUBS "mul(" == 
      (If it doesn't, the cursor must still be advanced by one character.)
      DUP NOT ':: #1 advance DROP ; IFT ;
    ::
      #4 advance
      (The next thing has to be a number.)
      ':: getdigits 
        (If there were digits, store them and proceed!)
        ':: >INT 'leftmul STO #1 ;
        evaliftrue ; 
      evaliftrue ;
    ::
      (Then a comma...)
      eol ':: text cursor GET "," == ; evaliftrue ; 
    ::
      #1 advance
      (Then another number.) 
      ':: getdigits
        (Store these digits too.)
        ':: >INT 'rightmul STO #1 ;
        evaliftrue ;
      evaliftrue ;
    ::
      (And finally, a close paren.)
      eol ':: text cursor GET ")" == ; evaliftrue ;
    ::
      (A victory dance for the successful.)
      #1 advance DROP
      (Do the multiplication if enabled.)
      enable
      ':: leftmul rightmul * total + 'total STO ;
      IFT
      (And tell the world of our triumph.)
      #1 ; }  
  
  ':: (Process one line of text.)
    ':: 
      '::
        (Don't actually care what the result is from replst; we're just
         chucking text at the rules until we hit the end of line.)
        rules replst DROP
        eol ;
      REP ;
    { rules text :cursor: #0 :eol: #1 :leftmul: #0 :rightmul: #0 } LOCAL ;
  
  '::
     (Part one: just the multiplication things, please.)
     input ':: rules parsestring ; FOREACH DROP "Part 1: " total + DISP 
     
     (Part two: add a couple of rules to the top of our parser to enable 
      and disable tallying as needed, then do this whole thing again.)
     #0 'total STO
     { :: text cursor DUP #3 + SUBS "do()" == 
         ':: #1 'enable STO #4 advance DROP #0 ; #1 IFTE ;
       :: text cursor DUP #6 + SUBS "don't()" ==
         ':: #0 'enable STO #7 advance DROP #0 ; #1 IFTE ; }
     rules + 'rules STO
     input ':: rules parsestring ; FOREACH DROP "Part 2: " total + DISP ;
  { parsestring rules getdigits evaliftrue advance input 
    :enable: #1 :total: #0 } LOCAL ;
'day03 STO


(Day 2: Nuclear watchdog)
'::
  (Retrieve and process our input, turning each line into a numerical list.
   Here we lean on the parser, which is just as happy to generate a list as
   it would be a single number.)
  "input02" READF POP DROP
  ':: " }" + "{ " SWAP + >OBJ update ; FOREACH

  (Reckon subroutine: evaluate rules ascending and descending together, 
                      returning the lower number of failures.)
  '::
    DUP LEN #1 -
      '::
        (Now loop through a single row.)
        (Our failure counts begin clear:) #0 #0
        '::
          (Fetch two adjacent numbers.)
          row idx DUP2 #1 - GET #3 ROLLD GET
          (Check that 0<difference<=3.)
          DUP2 - ABS DUP #0 > SWAP #3 <= AND
          (In bounds: increment appropriate fail count.)
          ':: >
            ':: #1 + ;
            ':: SWAP #1 + SWAP ;
            IFTE ;
          (Out of bounds: drop both numbers and increment both fail counts.)
          ':: DROP DROP #1 + SWAP #1 + SWAP ;
          IFTE
          (Continue until we're out of numbers.)
          idx #1 - DUP 'idx STO ; 
        REP 
        (Finally, return the lesser of the two results.)
        DUP2 < #3 ROLLD IFTE ;
      { idx row } LOCAL ;

  ':: 
    (Part 1: Tally the lines in which the delta between numbers is 1-3, and
             everything is moving the same direction.)
    (Our tally starts at zero:) #0
    (Start at the bottom of the list:) input LEN
    '::
      '::
        (Decrement our row index.)
        row #1 - 'row STO
        (Get and test a row.)
        input row GET reckon
        (Tally zero-error rows, and save a list of rows with 1 or 2 errors;
         any more will be an incorrectible error.)
        DUP
        ':: #2 <=
          ':: unsafe input row GET #1 >LST + 'unsafe STO ;
          IFT ;
        ':: NOT + ;
        IFTE
        row ;
      REP ;
    { row } LOCAL
    (Record our guaranteed safe count to add to part 2.)
    DUP 'safe STO
    "Part 1: " SWAP + DISP

    (Part 2: Tally the lines in which removing a single value will render
             the condition safe.)
    (Again our tally starts at zero:) #0
    (Start at the bottom of our new, smaller list:) unsafe LEN
    '::
      '::
        (Decrement row index and get next row.)
        row #1 - 'row STO
        (Excise each element in turn and re-test.)
        unsafe row GET DUP LEN #1 -
        '::
          ':: thisrow idx edit reckon 
            (Still unsafe, decrement and loop.)
            ':: idx DUP #1 - 'idx STO ;
            (Found a safe one, increment safe count and stop.)
            ':: #1 + #0 ;
            IFTE ;
          REP ;
        { idx thisrow } LOCAL
        row ;
      REP ;
    { row } LOCAL 
    (And add to our safe count from part 1 to get our final result.)
    safe + "Part 2: " SWAP + DISP ;
  { reckon input :unsafe: {} :safe: #0 } LOCAL ;
'day02 STO


(Day 1: Arguing with historians)
'::
  (First, retrieve our input as a list of strings, and discard the final
   empty line.)
  "input01" READF POP DROP

  '::
    (Then, for each line, parse the numbers into separate lists.)
    ':: >OBJ >INT listB + 'listB STO >INT listA + 'listA STO ;
    FOREACH DROP

    (Part 1: Read two columns of numbers, sort both, then return the sum of
             the absolute differences between each line.)
  
    (Sort the lists individually.)
    listA sort 'listA STO
    listB sort 'listB STO

    (Now obtain the sum of the absolute value of the differences in the lists.)
    (Our sum, left on stack:) #0
    (Our index:) listA LEN
    '::
      '::
        (Back through both lists.  Initial LEN points us to one past the end.)
        idx #1 - 'idx STO        
        (Fetch an item from each list.)
        listA idx GET
        listB idx GET
        (Find the absolute difference and add to our sum.)
        - ABS +
        (Repeat until our index is 0.)
        idx ;
      REP ;
    { idx } LOCAL 
    "Part one: " SWAP + DISP 

    (Part 2: Count the number of matches in list B of every entry in list A,
             then sum value*matches for each line.  The fact that we're
             already sorted will hasten our search.)
    (Our sum:) #0
    (Our A-index and also stop value for the B list:) listA LEN DUP #1 -
    '::
      '::
        (Get a test value from the A list.) 
        listA idx #1 - DUP 'idx STO GET 'itemA STO

        (Now search the B list for matches, if there are any left.)
        (Our match count:) #0
        (Which will remain zero if we're out of numbers.) max #0 >=
        '::
          '::
            (Prepare two tests: listB=listA, and listB>=listA.)
            listB max GET itemA
            DUP2 == #3 ROLLD >=
            (If >=, we use the == test as an integer to increment match
             count, and in either case seek downward.
             If <, our == is a guaranteed false and falls through to stop REP.)
            ':: + max #1 - 'max STO 
              (And leave this truth for REP:) #1 ;
            IFT
            (Also make sure we aren't out of list B indices.)
            max #0 >= AND ;
          REP ;
        IFT

        (Now multiply our count and test value, sum it, and loop.)
        itemA * +
        idx ;
      REP 
      "Part two: " SWAP + DISP ;
    { :itemA: () max idx } LOCAL ;
  { :listA: {} :listB: {} } LOCAL ;
'day01 STO


(General routines)

(This routine was developed straight from the algorithm, and I used it
 for 2023:7, inter alia, where a sort routine was required.)
'::
  (This is our local partition routine, which divides the list into two
   partitions.)
  '::
    '::
      (Make a pivot value in the middle of our part of the array.)
      list hi lo - #2 / lo + GET EVAL 'pivot STO

      lo #1 - 'lo STO
      hi #1 + 'hi STO
      '::
        (Move the left index right at least once, while the element at that
         index is less than the pivot.)
        ':: list lo #1 + DUP 'lo STO GET EVAL pivot < ; REP

        (Move the right index left at least once, while the element at that
         index is greater than the pivot.)
        ':: list hi #1 - DUP 'hi STO GET EVAL pivot > ; REP

        lo hi >=

        (If the indices crossed, fall out of the loop and return the 'hi' value.)
        ':: hi #0 ;

        (Else, swap the elements under our two cursors and repeat.)
        ':: list hi GET list DUP lo GET
           hi PUT
           SWAP lo PUT 'list STO #1 ;
        IFTE ;
      REP ; 
    { hi lo :pivot:#0 } LOCAL ;

  (This is our local recursion routine.  It sorts some or all of the list,
   divides it into partitions, then sorts those.)
  '::
    '::
      lo #0 >= hi #0 >= AND lo hi < AND
      '::
        lo hi partition 'p STO 
        lo p recurse
        p #1 + hi recurse ;
      IFT ;
    { hi lo :p:() } LOCAL ;

  (This is the local environment into which our subroutines go.  It presents
   a nicer interface to the user by passing on the full bounds of the list
   to start 'recurse' instead of making someone else do it.)
  ':: #0 list LEN #1 - recurse list ; 
  { recurse partition list } LOCAL ;
{ EVAL } STATIC
'sort STO


(Edit a single item out of a list.)
'::
  '::
    (Cut to left of index.)
    DUP idx LEFT
    (Cut to right of index and stitch together.)
    SWAP DUP LEN idx - #1 - RIGHT + ;
  { idx } LOCAL ;
'edit STO


(Evaluate the contents of a list in order, advancing after each list item
 which returns true, and stopping for the first item which returns false. 
 Returns true if each element also returned true.)
'::
  DUP LEN
  '::
    ':: 
      (Evaluate a list item.)
      _list _idx GETE DUP
      (Increment index and see if we a. succeeded and b. are not done.)
      _idx #1 + DUP '_idx STO _max < AND
      (Only pass our result on if we're leaving.)
      DUP 'DROP IFT ;
    REP ;
  { :_idx: #0 _max _list } LOCAL ;
'replst STO


(Take a gander to see if a character is numeric.)
':: { "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" } SWAP HAS ;
'isnumeral STO


(Grab from some point to the end of a list or string.)
':: SWAP DUP LEN #3 ROLL - RIGHT ;
STATICN
'heretoend STO


(Swap two elements in a list.)
'::
  ':: list DUP x GET list y GET #3 ROLL SWAP x PUT SWAP y PUT ;
  { x y list } LOCAL ;
'swapelements STO


(Put a thing into a 2d list.  Accepts list, x, y, thing.)
'::
  (Quote the thing so it doesn't get evaluated.) QUOTE
  ':: DUP y GET thing x PUT y PUT ; { thing y x } LOCAL ;
'put2d STO


(Get thing from a 2d list.)
'::
  ':: list y GET x GET ; { y x list } LOCAL ;
'get2d STO


(Reverse a list.  This blows up a list and reassembles it,
 using the ability to multiply code.)
'::
  OBJ> ':: SWAP + ; SWAP * {} SWAP EVAL ;
'revlst STO


(Sum a list.)
':: OBJ> ':: + ; SWAP #1 - * EVAL ;
'sumlst STO


(Lisp functions.)
':: #0 GET ; 'car STO
':: #1 heretoend ; 'cdr STO


(Pick the lesser of two items.)
':: DUP2 < #3 ROLLD IFTE ; 'lesser STO


(Pick the greater of two items.)
':: DUP2 > #3 ROLLD IFTE ; 'greater STO


(Evaluate a thing against every item in a list.  Accepts code and a list.)
':: SWAP DUP LEN #1 - #3 ROLL SWAP * ':: OBJ> DROP ; SWAP + EVAL ;
'evalagainst STO


(Check if a pair of coordinates are in bounds.)
':: DUP #0 >= SWAP ybound < AND
  SWAP DUP #0 >= SWAP xbound < AND AND ;
'bounded STO


(For each valid cardinal direction from a given start point,
 evaluate an object against new X and Y coordinates.  Accepts an evaluator
 and start coordinates.)
':: 
  '::
    x y #1 - DUP2 bounded 'evaluator ':: DROP DROP ; IFTE
    x #1 + y DUP2 bounded 'evaluator ':: DROP DROP ; IFTE
    x y #1 + DUP2 bounded 'evaluator ':: DROP DROP ; IFTE
    x #1 - y DUP2 bounded 'evaluator ':: DROP DROP ; IFTE ;
  { evaluator } LOCAL ;
'paint STO
